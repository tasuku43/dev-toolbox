#!/usr/bin/env bash
# name-audit (bash 3.2 compatible; macOS default bash OK)
#
# What it does:
# - Homebrew exact name collision
# - apt-file command-path collision
# - dnf command-path collision
# - npm: sandbox global install to temp prefix -> checks SAME-NAME bin
# - PyPI: sandbox venv install -> checks SAME-NAME script
# - Final result: whether install-time command collision is likely
#
# Usage:
#   ./name-audit <candidate-name> <candidate-name>
#
# Env:
#   TIMEOUT_SECS=25
#   KEEP_TMP=1
#   NPM_FAIL_WEEKLY=1000
#   PYPI_FAIL_MONTHLY=2000
#   PYPI_RETRY_TIMEOUT_SECS=90

set -euo pipefail

TIMEOUT_SECS="${TIMEOUT_SECS:-25}"
KEEP_TMP="${KEEP_TMP:-0}"
NPM_FAIL_WEEKLY="${NPM_FAIL_WEEKLY:-1000}"
PYPI_FAIL_MONTHLY="${PYPI_FAIL_MONTHLY:-2000}"
PYPI_RETRY_TIMEOUT_SECS="${PYPI_RETRY_TIMEOUT_SECS:-90}"
NO_COLOR="${NO_COLOR:-0}"

if [[ "$NO_COLOR" == "1" ]]; then
  USE_COLOR=0
else
  USE_COLOR=1
fi

style() {
  local code="$1"
  local text="$2"
  if [[ "$USE_COLOR" == "1" ]]; then
    printf '\033[%sm%s\033[0m' "$code" "$text"
  else
    printf '%s' "$text"
  fi
}

color_status() {
  local s="$1"
  case "$s" in
    FAIL|HIGH) style "31;1" "$s" ;;
    WARN|FOUND|CAUTION|NOTICE) style "33;1" "$s" ;;
    PASS|OK|CLEAR) style "32;1" "$s" ;;
    SKIP|SKIPPED) style "2" "$s" ;;
    *) style "0" "$s" ;;
  esac
}

have() { command -v "$1" >/dev/null 2>&1; }

run_timeout_with_secs() {
  local secs="$1"
  shift
  if have timeout; then
    timeout "${secs}" "$@" 2>/dev/null
    return $?
  elif have gtimeout; then
    gtimeout "${secs}" "$@" 2>/dev/null
    return $?
  elif have python3; then
    python3 - "$secs" "$@" 2>/dev/null <<'PY'
import subprocess
import sys

timeout_secs = float(sys.argv[1])
cmd = sys.argv[2:]
if not cmd:
    sys.exit(0)

try:
    completed = subprocess.run(cmd, timeout=timeout_secs)
    sys.exit(completed.returncode)
except subprocess.TimeoutExpired:
    sys.exit(124)
except Exception:
    sys.exit(1)
PY
    return $?
  else
    "$@" 2>/dev/null
    return $?
  fi
}

run_timeout() {
  run_timeout_with_secs "$TIMEOUT_SECS" "$@"
}

run_check_with_progress() {
  local label="$1"
  local fn="$2"
  local name="$3"
  local start end elapsed rc dots_pid done_label fail_label

  start="$(date +%s)"
  printf "Checking %s..." "$label"
  (
    while true; do
      sleep 1
      printf "."
    done
  ) &
  dots_pid=$!
  rc=0
  "$fn" "$name" || rc=$?
  kill "$dots_pid" >/dev/null 2>&1 || true
  wait "$dots_pid" 2>/dev/null || true
  end="$(date +%s)"
  elapsed=$((end - start))
  done_label="$(style "36;1" "done")"
  fail_label="$(style "31;1" "failed")"

  if [[ $rc -eq 0 ]]; then
    printf " %s (%ss)\n" "$done_label" "$elapsed"
  else
    printf " %s (%ss, rc=%s)\n" "$fail_label" "$elapsed" "$rc"
  fi
  return "$rc"
}

print_h1() {
  local header
  header="=== $1 ==="
  if [[ "$USE_COLOR" == "1" ]]; then
    style "36;1" "$header"
    printf "\n"
  else
    echo "$header"
  fi
}

print_line() {
  local label="$1"; shift
  local status="$1"; shift
  local details="$*"
  CHECK_LABELS+=("$label")
  CHECK_STATUS+=("$status")
  CHECK_DETAILS+=("$details")
}

mktempdir() {
  if have mktemp; then
    mktemp -d 2>/dev/null || mktemp -d -t name-audit
  else
    local d="/tmp/name-audit.$$.$RANDOM"
    mkdir -p "$d"
    echo "$d"
  fi
}

cleanup_dir() {
  local d="$1"
  [[ "$KEEP_TMP" == "1" ]] && return 0
  rm -rf "$d" >/dev/null 2>&1 || true
}

list_bins_in_dir() {
  local bindir="$1"
  if [[ -d "$bindir" ]]; then
    (cd "$bindir" && ls -1 2>/dev/null | sed '/^\s*$/d') || true
  fi
}

# Globals per-name
VERDICT="OK"
FAIL_REASONS=()
WARN_REASONS=()
CHECK_LABELS=()
CHECK_STATUS=()
CHECK_DETAILS=()

set_verdict() {
  # FAIL > WARN > OK
  local new="$1"
  case "$VERDICT" in
    FAIL)
      return 0
      ;;
    WARN)
      if [[ "$new" == "FAIL" ]]; then
        VERDICT="FAIL"
      fi
      return 0
      ;;
    OK)
      if [[ "$new" == "WARN" || "$new" == "FAIL" ]]; then
        VERDICT="$new"
      fi
      return 0
      ;;
    *)
      VERDICT="$new"
      return 0
      ;;
  esac
}

add_fail_reason() { FAIL_REASONS+=("$1"); }
add_warn_reason() { WARN_REASONS+=("$1"); }

trim() {
  local s="$1"
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf "%s" "$s"
}

context_risk_for() {
  local label="$1"
  local details="$2"
  local n

  if [[ "$label" == "Homebrew" || "$label" == "apt-file" || "$label" == "dnf" ]]; then
    if [[ "$details" == *"exact"* ]]; then
      echo "HIGH"
    else
      echo "CLEAR"
    fi
    return 0
  fi

  if [[ "$details" != *"same-name"* ]]; then
    echo "CLEAR"
    return 0
  fi

  if [[ "$details" =~ downloads/week=([0-9]+) ]]; then
    n="${BASH_REMATCH[1]}"
    if [[ "$n" -ge "$NPM_FAIL_WEEKLY" ]]; then
      echo "HIGH"
    else
      echo "CAUTION"
    fi
    return 0
  fi

  if [[ "$details" =~ downloads/month=([0-9]+) ]]; then
    n="${BASH_REMATCH[1]}"
    if [[ "$n" -ge "$PYPI_FAIL_MONTHLY" ]]; then
      echo "HIGH"
    else
      echo "CAUTION"
    fi
    return 0
  fi

  echo "CAUTION"
}

check_brew() {
  local name="$1"
  if ! have brew; then
    print_line "Homebrew" "SKIPPED" "brew not installed"
    return 0
  fi

  local out_f out_c hit_f="NO" hit_c="NO"

  out_f="$(run_timeout brew search --formula "$name" || true)"
  if [[ -n "$out_f" ]] && echo "$out_f" | awk -v n="$name" '$0==n{f=1} END{exit(f?0:1)}' >/dev/null 2>&1; then
    hit_f="YES"
  fi

  out_c="$(run_timeout brew search --cask "$name" || true)"
  if [[ -n "$out_c" ]] && echo "$out_c" | awk -v n="$name" '$0==n{f=1} END{exit(f?0:1)}' >/dev/null 2>&1; then
    hit_c="YES"
  fi

  if [[ "$hit_f" == "YES" || "$hit_c" == "YES" ]]; then
    print_line "Homebrew" "FOUND" "exact match; formula=${hit_f}; cask=${hit_c}"
    set_verdict "FAIL"
    add_fail_reason "Homebrew: exact match exists"
  else
    print_line "Homebrew" "CLEAR" "no exact match"
  fi
}

check_apt_file() {
  local name="$1"
  if ! have apt-file; then
    print_line "apt-file" "SKIPPED" "apt-file not installed"
    return 0
  fi

  local out
  out="$(run_timeout apt-file search --regexp "(^|/)(usr/)?(s)?bin/${name}$" 2>/dev/null || true)"
  if [[ -n "$out" ]]; then
    print_line "apt-file" "FOUND" "exact command path exists"
    set_verdict "FAIL"
    add_fail_reason "apt-file: exact command path exists"
  else
    print_line "apt-file" "CLEAR" "no exact command path match"
  fi
}

check_dnf() {
  local name="$1"
  if ! have dnf; then
    print_line "dnf" "SKIPPED" "dnf not installed"
    return 0
  fi

  local out
  out="$(run_timeout dnf -q repoquery --whatprovides "*/bin/${name}" 2>/dev/null || true)"
  if [[ -n "$out" ]] && ! echo "$out" | awk 'tolower($0) ~ /no matches found/{f=1} END{exit(f?0:1)}' >/dev/null 2>&1; then
    print_line "dnf" "FOUND" "exact command path exists"
    set_verdict "FAIL"
    add_fail_reason "dnf: exact command path exists"
  else
    print_line "dnf" "CLEAR" "no exact command path match"
  fi
}

print_context() {
  echo "CONTEXT:"
  if [[ "${#CHECK_LABELS[@]}" -eq 0 ]]; then
    echo "- (no checks)"
    return 0
  fi

  local i label status details status_colored risk risk_colored part part_fmt
  for ((i=0; i<${#CHECK_LABELS[@]}; i++)); do
    label="${CHECK_LABELS[$i]}"
    status="${CHECK_STATUS[$i]}"
    details="${CHECK_DETAILS[$i]}"
    status_colored="$(color_status "$status")"

    if [[ "$status" != "FOUND" ]]; then
      if [[ -n "$details" ]]; then
        echo "- ${label}: ${status_colored} (${details})"
      else
        echo "- ${label}: ${status_colored}"
      fi
      continue
    fi

    risk="$(context_risk_for "$label" "$details")"
    risk_colored="$(color_status "$risk")"
    if [[ "$risk" == "CLEAR" ]]; then
      echo "- ${label}: ${risk_colored}"
      continue
    fi
    echo "- ${label}: ${risk_colored}"
    echo "  Evidence:"

    IFS=';' read -r -a parts <<< "$details"
    for part in "${parts[@]}"; do
      part="$(trim "$part")"
      [[ -n "$part" ]] || continue
      part_fmt="${part//=/: }"
      echo "    ${part_fmt}"
    done
  done
}

# JSON helper using python3 (already required for venv)
json_py_get_int() {
  # reads json from stdin and prints int or empty
  local expr="$1"
  python3 -c 'import json,sys
expr=sys.argv[1]
s=sys.stdin.read()
if not s:
    print("")
    raise SystemExit(0)
try:
    j=json.loads(s)
except Exception:
    print("")
    raise SystemExit(0)
try:
    v=eval(expr, {"__builtins__": {}}, {"j": j})
    if v is None:
        print("")
    elif isinstance(v,(int,float)):
        print(int(v))
    else:
        try:
            print(int(v))
        except Exception:
            print("")
except Exception:
    print("")
' "$expr"
}

npm_bins_from_view_json() {
  # reads npm view --json output from stdin and prints bin names (1 per line)
  python3 -c 'import json,sys
s=sys.stdin.read()
if not s:
    raise SystemExit(0)
try:
    j=json.loads(s)
except Exception:
    raise SystemExit(0)
if isinstance(j, list):
    if not j:
        raise SystemExit(0)
    j=j[-1]
b=j.get("bin") if isinstance(j, dict) else None
if isinstance(b, str):
    print(b)
elif isinstance(b, dict):
    for k in b.keys():
        print(k)
'
}

npm_view_has_package() {
  # reads npm view --json output from stdin, exits 0 when package metadata exists
  python3 -c 'import json,sys
s=sys.stdin.read()
if not s:
    raise SystemExit(1)
try:
    j=json.loads(s)
except Exception:
    raise SystemExit(1)
if isinstance(j, list):
    j=j[-1] if j else {}
if isinstance(j, dict) and isinstance(j.get("error"), dict):
    raise SystemExit(1)
if isinstance(j, dict) and ("version" in j or "bin" in j):
    raise SystemExit(0)
raise SystemExit(1)
'
}

npm_downloads_last_week() {
  local pkg="$1"
  have curl || { NPM_DL_LAST_WEEK=""; return 0; }
  local body
  body="$(run_timeout curl -fsS "https://api.npmjs.org/downloads/point/last-week/${pkg}" || true)"
  [[ -n "$body" ]] || { NPM_DL_LAST_WEEK=""; return 0; }
  NPM_DL_LAST_WEEK="$(echo "$body" | json_py_get_int "j.get('downloads')")"
}

NPM_DL_LAST_WEEK=""
PYPI_DL_LAST_MONTH=""

pypi_downloads_last_month() {
  local pkg="$1"
  have curl || { PYPI_DL_LAST_MONTH=""; return 0; }
  local body
  body="$(run_timeout curl -fsS "https://pypistats.org/api/packages/${pkg}/recent" || true)"
  [[ -n "$body" ]] || { PYPI_DL_LAST_MONTH=""; return 0; }
  PYPI_DL_LAST_MONTH="$(echo "$body" | json_py_get_int "j.get('data',{}).get('last_month')")"
}

pypi_scripts_from_wheels_dir() {
  # $1: directory containing downloaded wheel files
  # prints console script names (1 per line)
  local dist_dir="$1"
  python3 - "$dist_dir" <<'PY'
import configparser
import io
import pathlib
import sys
import zipfile

dist_dir = pathlib.Path(sys.argv[1])
seen = set()

for whl in dist_dir.glob("*.whl"):
    try:
        with zipfile.ZipFile(whl) as zf:
            ep_files = [n for n in zf.namelist() if n.endswith(".dist-info/entry_points.txt")]
            for ep in ep_files:
                data = zf.read(ep).decode("utf-8", errors="ignore")
                cp = configparser.ConfigParser()
                cp.read_file(io.StringIO(data))
                if cp.has_section("console_scripts"):
                    for key, _val in cp.items("console_scripts"):
                        if key not in seen:
                            seen.add(key)
                            print(key)
    except Exception:
        continue
PY
}

check_npm() {
  local name="$1"
  if ! have npm; then
    print_line "npm" "SKIPPED" "npm not installed"
    return 0
  fi

  local view_body bins_from_view dl same="NO"
  view_body="$(run_timeout npm view "$name" version bin dist-tags --json 2>/dev/null || true)"
  bins_from_view="$(echo "$view_body" | npm_bins_from_view_json || true)"

  if [[ -z "$view_body" ]] || ! echo "$view_body" | npm_view_has_package >/dev/null 2>&1; then
    print_line "npm" "CLEAR" "package not found"
    return 0
  fi

  npm_downloads_last_week "$name"
  dl="$NPM_DL_LAST_WEEK"
  [[ -z "$dl" ]] && dl="unknown"

  if [[ -n "$bins_from_view" ]] && echo "$bins_from_view" | awk -v n="$name" '$0==n{f=1} END{exit(f?0:1)}' >/dev/null 2>&1; then
    same="YES"
  fi

  if [[ "$same" == "YES" ]]; then
    print_line "npm" "FOUND" "same-name bin '${name}' created; downloads/week=${dl}"
    if [[ "$dl" != "unknown" ]] && [[ "$dl" -ge "$NPM_FAIL_WEEKLY" ]]; then
      set_verdict "FAIL"
      add_fail_reason "npm: same-name executable '${name}' exists (popular: ${dl}/week)"
    else
      set_verdict "WARN"
      add_warn_reason "npm: same-name executable '${name}' exists (low/unknown popularity: ${dl}/week)"
    fi
  elif [[ -n "$bins_from_view" ]]; then
    print_line "npm" "FOUND" "package exists; no same-name bin '${name}'; downloads/week=${dl}"
  else
    print_line "npm" "FOUND" "package exists; no executable metadata; downloads/week=${dl}"
  fi
}

check_pypi() {
  local name="$1"
  if ! have python3; then
    print_line "PyPI" "SKIPPED" "python3 not installed"
    return 0
  fi
  if ! run_timeout python3 -m pip --version >/dev/null 2>&1; then
    print_line "PyPI" "SKIPPED" "pip not available for python3"
    return 0
  fi

  # Existence probe (fast) when curl is available.
  # If curl is unavailable, continue and rely on wheel/install probes.
  if have curl; then
    if ! run_timeout curl -fsS "https://pypi.org/pypi/${name}/json" >/dev/null 2>&1; then
      print_line "PyPI" "CLEAR" "package not found"
      return 0
    fi
  fi

  # Fast path: inspect console scripts from wheel metadata first.
  # This avoids expensive venv creation/install for common binary-wheel packages.
  local tmp dist_dir wheel_rc wheel_scripts dl
  tmp="$(mktempdir)"
  dist_dir="${tmp}/dist"
  mkdir -p "$dist_dir"
  wheel_rc=0
  run_timeout_with_secs "$PYPI_RETRY_TIMEOUT_SECS" \
    python3 -m pip download -q --disable-pip-version-check --no-deps --only-binary=:all: --dest "$dist_dir" "$name" >/dev/null 2>&1 || wheel_rc=$?
  if [[ $wheel_rc -eq 0 ]]; then
    wheel_scripts="$(pypi_scripts_from_wheels_dir "$dist_dir" || true)"
    pypi_downloads_last_month "$name"
    dl="$PYPI_DL_LAST_MONTH"
    [[ -z "$dl" ]] && dl="unknown"

    if [[ -n "$wheel_scripts" ]] && echo "$wheel_scripts" | awk -v n="$name" '$0==n{f=1} END{exit(f?0:1)}' >/dev/null 2>&1; then
      print_line "PyPI" "FOUND" "same-name script '${name}' created; downloads/month=${dl}"
      if [[ "$dl" != "unknown" ]] && [[ "$dl" -ge "$PYPI_FAIL_MONTHLY" ]]; then
        set_verdict "FAIL"
        add_fail_reason "PyPI: same-name executable '${name}' exists (popular: ${dl}/month)"
      else
        set_verdict "WARN"
        add_warn_reason "PyPI: same-name executable '${name}' exists (low/unknown popularity: ${dl}/month)"
      fi
    elif [[ -n "$wheel_scripts" ]]; then
      print_line "PyPI" "FOUND" "package exists; no same-name script '${name}'; downloads/month=${dl}"
    else
      print_line "PyPI" "FOUND" "package exists; wheel has no console scripts; downloads/month=${dl}"
    fi
    cleanup_dir "$tmp"
    return 0
  fi
  cleanup_dir "$tmp"

  # Fallback path: full venv install for packages without usable wheel metadata.
  local venv bindir rc scripts same="NO"
  tmp="$(mktempdir)"
  venv="${tmp}/venv"

  rc=0
  run_timeout python3 -m venv "$venv" >/dev/null 2>&1 || rc=$?
  if [[ $rc -ne 0 ]]; then
    if [[ $rc -eq 124 ]]; then
      print_line "PyPI" "SKIPPED" "timeout creating venv; timeout=${TIMEOUT_SECS}s"
    else
      print_line "PyPI" "SKIPPED" "failed to create venv; rc=${rc}"
    fi
    cleanup_dir "$tmp"
    return 0
  fi

  bindir="${venv}/bin"
  [[ -d "$bindir" ]] || bindir="${venv}/Scripts"

  rc=0
  run_timeout "${bindir}/python" -m pip install -q "$name" >/dev/null 2>&1 || rc=$?
  if [[ $rc -eq 124 ]] && [[ "$PYPI_RETRY_TIMEOUT_SECS" -gt "$TIMEOUT_SECS" ]]; then
    rc=0
    run_timeout_with_secs "$PYPI_RETRY_TIMEOUT_SECS" "${bindir}/python" -m pip install -q "$name" >/dev/null 2>&1 || rc=$?
  fi
  if [[ $rc -ne 0 ]]; then
    local wheel_scripts dl
    dist_dir="${tmp}/dist"
    mkdir -p "$dist_dir"
    wheel_rc=0
    run_timeout_with_secs "$PYPI_RETRY_TIMEOUT_SECS" "${bindir}/python" -m pip download -q --no-deps --only-binary=:all: --dest "$dist_dir" "$name" >/dev/null 2>&1 || wheel_rc=$?
    if [[ $wheel_rc -eq 0 ]]; then
      wheel_scripts="$(pypi_scripts_from_wheels_dir "$dist_dir" || true)"
      pypi_downloads_last_month "$name"
      dl="$PYPI_DL_LAST_MONTH"
      [[ -z "$dl" ]] && dl="unknown"
      if [[ -n "$wheel_scripts" ]] && echo "$wheel_scripts" | awk -v n="$name" '$0==n{f=1} END{exit(f?0:1)}' >/dev/null 2>&1; then
        print_line "PyPI" "FOUND" "same-name script '${name}' via wheel metadata; downloads/month=${dl}; install_rc=${rc}"
        if [[ "$dl" != "unknown" ]] && [[ "$dl" -ge "$PYPI_FAIL_MONTHLY" ]]; then
          set_verdict "FAIL"
          add_fail_reason "PyPI: same-name executable '${name}' exists (popular: ${dl}/month; wheel metadata)"
        else
          set_verdict "WARN"
          add_warn_reason "PyPI: same-name executable '${name}' exists (low/unknown popularity: ${dl}/month; wheel metadata)"
        fi
      elif [[ -n "$wheel_scripts" ]]; then
        print_line "PyPI" "FOUND" "package exists; no same-name script '${name}' via wheel metadata; downloads/month=${dl}; install_rc=${rc}"
      else
        print_line "PyPI" "SKIPPED" "install failed; wheel metadata had no console scripts; rc=${rc}"
      fi
      cleanup_dir "$tmp"
      return 0
    fi

    if [[ $rc -eq 124 ]]; then
      print_line "PyPI" "SKIPPED" "timeout installing temp venv; timeout=${TIMEOUT_SECS}s; retry=${PYPI_RETRY_TIMEOUT_SECS}s"
    else
      print_line "PyPI" "SKIPPED" "failed installing package in temp venv; rc=${rc}"
    fi
    cleanup_dir "$tmp"
    return 0
  fi

  scripts="$(list_bins_in_dir "$bindir")"
  if [[ -z "$scripts" ]]; then
    print_line "PyPI" "FOUND" "package exists; install created no scripts"
    cleanup_dir "$tmp"
    return 0
  fi

  if echo "$scripts" | awk -v n="$name" '$0==n{f=1} END{exit(f?0:1)}' >/dev/null 2>&1; then
    same="YES"
  fi

  local dl
  pypi_downloads_last_month "$name"
  dl="$PYPI_DL_LAST_MONTH"
  [[ -z "$dl" ]] && dl="unknown"

  if [[ "$same" == "YES" ]]; then
    print_line "PyPI" "FOUND" "same-name script '${name}' created; downloads/month=${dl}"
    if [[ "$dl" != "unknown" ]] && [[ "$dl" -ge "$PYPI_FAIL_MONTHLY" ]]; then
      set_verdict "FAIL"
      add_fail_reason "PyPI: same-name executable '${name}' exists (popular: ${dl}/month)"
    else
      set_verdict "WARN"
      add_warn_reason "PyPI: same-name executable '${name}' exists (low/unknown popularity: ${dl}/month)"
    fi
  else
    print_line "PyPI" "FOUND" "package exists; no same-name script '${name}'; downloads/month=${dl}"
  fi

  cleanup_dir "$tmp"
}

print_verdict() {
  local risk_text risk_colored
  if [[ "$VERDICT" == "FAIL" ]]; then
    risk_text="HIGH"
  elif [[ "$VERDICT" == "WARN" ]]; then
    risk_text="CAUTION"
  else
    risk_text="CLEAR"
  fi
  risk_colored="$(color_status "$risk_text")"
  echo
  echo "RISK: ${risk_colored}"
  echo "Why:"
  if [[ "$VERDICT" == "FAIL" ]] && [[ "${#FAIL_REASONS[@]}" -gt 0 ]]; then
    local r x_mark
    x_mark="$(style "31;1" "âœ—")"
    for r in "${FAIL_REASONS[@]}"; do
      echo "  ${x_mark} ${r}"
    done
  elif [[ "$VERDICT" == "WARN" ]] && [[ "${#WARN_REASONS[@]}" -gt 0 ]]; then
    local r
    for r in "${WARN_REASONS[@]}"; do
      echo "  - ${r}"
    done
  else
    echo "  - no blocking collision found in checked ecosystems"
  fi
  echo

  print_context
}

main() {
  if [[ "$#" -eq 0 ]]; then
    echo "Usage: $0 <candidate-name> <candidate-name>" >&2
    exit 2
  fi

  local n
  for n in "$@"; do
    [[ -n "$n" ]] || continue
    if [[ "$n" == -* ]]; then
      echo "ERR: options are not supported. Pass candidate names directly." >&2
      echo "Usage: $0 <candidate-name> <candidate-name>" >&2
      exit 2
    fi
    VERDICT="OK"
    FAIL_REASONS=()
    WARN_REASONS=()
    CHECK_LABELS=()
    CHECK_STATUS=()
    CHECK_DETAILS=()

    print_h1 "$n"
    run_check_with_progress "Homebrew" check_brew "$n"
    run_check_with_progress "apt-file" check_apt_file "$n"
    run_check_with_progress "dnf" check_dnf "$n"
    run_check_with_progress "npm" check_npm "$n"
    run_check_with_progress "PyPI" check_pypi "$n"
    print_verdict
    echo
  done
}

main "$@"
